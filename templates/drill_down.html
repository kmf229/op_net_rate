{% extends "base.html" %}

{% block title %}Drill Down - {{ driver.title() }}{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb" id="drillBreadcrumb">
                <li class="breadcrumb-item"><a href="{{ url_for('index') }}">Dashboard</a></li>
                <li class="breadcrumb-item active">{{ driver.title().replace('_', ' ') }} Analysis</li>
            </ol>
        </nav>
        
        <h1 id="drillTitle">{{ driver.title().replace('_', ' ') }} by Region</h1>
        <p class="lead">Click any row to drill down to the next level</p>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-3">
        <label for="analysisView" class="form-label">View</label>
        <select class="form-control" id="analysisView" onchange="saveFilterSettings(); updateDrillDown()">
            <option value="MTD">MTD</option>
            <option value="QTD">QTD</option>
            <option value="YTD">YTD</option>
        </select>
    </div>
    <div class="col-md-3">
        <label for="currentMonth" class="form-label">Current Month</label>
        <select class="form-control" id="currentMonth" onchange="saveFilterSettings(); updateDrillDown()">
            <option value="1">January</option>
            <option value="2">February</option>
            <option value="3">March</option>
            <option value="4">April</option>
            <option value="5">May</option>
            <option value="6">June</option>
            <option value="7">July</option>
            <option value="8">August</option>
            <option value="9">September</option>
            <option value="10">October</option>
            <option value="11" selected>November</option>
            <option value="12">December</option>
        </select>
    </div>
    <div class="col-md-3">
        <label for="currentYear" class="form-label">Year</label>
        <select class="form-control" id="currentYear" onchange="saveFilterSettings(); updateDrillDown()">
            <option value="2024">2024</option>
            <option value="2025" selected>2025</option>
        </select>
    </div>
    <div class="col-md-3 d-flex align-items-end">
        <button class="btn btn-outline-secondary btn-sm" id="backUpBtn" onclick="drillUp()">
            <span id="backUpText">← Back to Dashboard</span>
        </button>
    </div>
</div>

<div class="row">
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0" id="tableTitle">Performance by Region</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover" id="drillDownTable">
                        <thead id="tableHeaders">
                            <!-- Headers will be populated dynamically based on driver -->
                        </thead>
                        <tbody>
                            <!-- Data will be populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-lg-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">Recommended Actions</h5>
            </div>
            <div class="card-body">
                <div id="actionRecommendations">
                    <!-- Actions will be populated based on driver -->
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
const driver = '{{ driver }}';

// Navigation state
let currentLevel = 'region';
let navigationStack = [];
let currentParentId = null;

// Table sorting state
let currentTableData = [];
let currentSortColumn = -1;
let currentSortDirection = 'asc';

document.addEventListener('DOMContentLoaded', function() {
    // Load saved filter settings first
    loadFilterSettings();
    
    // Show loading state immediately
    showLoadingState();
    updateDrillDown();
    loadActionRecommendations();
    updateBackButton();
});

function showLoadingState() {
    const tableTitle = document.getElementById('tableTitle');
    const tableHeaders = document.getElementById('tableHeaders');
    const tableBody = document.querySelector('#drillDownTable tbody');
    
    tableTitle.textContent = 'Loading...';
    tableHeaders.innerHTML = '<tr><th>Loading data...</th></tr>';
    tableBody.innerHTML = '<tr><td><div class="spinner-border spinner-border-sm"></div> Loading...</td></tr>';
}

function updateDrillDown() {
    const analysisView = document.getElementById('analysisView').value;
    const currentMonth = parseInt(document.getElementById('currentMonth').value);
    const currentYear = parseInt(document.getElementById('currentYear').value);
    
    const params = new URLSearchParams({
        view_type: analysisView,
        current_month: currentMonth,
        current_year: currentYear,
        level: currentLevel
    });
    
    if (currentParentId) {
        params.append('parent_id', currentParentId);
    }
    
    const apiUrl = `/api/drill-down/${driver}?${params}`;
    console.log('Fetching drill-down data from:', apiUrl);
    
    fetch(apiUrl)
        .then(response => {
            console.log('Response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Drill-down data received:', data);
            updateTableHeaders();
            updateDrillDownTable(data);
            updateBreadcrumb();
        })
        .catch(error => {
            console.error('Error fetching drill-down data:', error);
            const tableTitle = document.getElementById('tableTitle');
            const tableBody = document.querySelector('#drillDownTable tbody');
            tableTitle.textContent = 'Error loading data';
            tableBody.innerHTML = '<tr><td colspan="5">Error: ' + error.message + '</td></tr>';
        });
}

function updateTableHeaders() {
    const thead = document.getElementById('tableHeaders');
    const levelName = currentLevel.charAt(0).toUpperCase() + currentLevel.slice(1);
    
    // Get driver-specific columns
    const columns = getDriverColumns(driver, levelName);
    
    thead.innerHTML = `
        <tr>
            ${columns.map((col, index) => `
                <th class="sortable-header" data-column="${index}" style="cursor: pointer; user-select: none;">
                    ${col} <span class="sort-indicator"></span>
                </th>
            `).join('')}
            <th>Track</th>
        </tr>
    `;
    
    document.getElementById('tableTitle').textContent = `${driver.replace('_', ' ').toUpperCase()} by ${levelName}`;
    
    // Add click listeners for sorting
    thead.querySelectorAll('.sortable-header').forEach(header => {
        header.addEventListener('click', () => {
            const columnIndex = parseInt(header.getAttribute('data-column'));
            sortTableByColumn(columnIndex, header);
        });
    });
}

function getDriverColumns(driverKey, levelName) {
    const driverColumns = {
        'units_per_visit': [
            levelName, 'Prev Units/Visit', 'Cur Units/Visit', 'Change', '$ Impact'
        ],
        'copay_leakage': [
            levelName, 'Expected Copay', 'Actual Copay', 'Capture %', '$ Impact'  
        ],
        'copay_collection': [
            levelName, 'Expected Copay', 'Actual Copay', 'Capture %', '$ Impact'
        ],
        'payer_mix': [
            levelName, 'Medicare %', 'Commercial %', 'Medicaid %', '$ Impact'
        ],
        'writeoffs_denials': [
            levelName, 'Write-offs', 'Denial Rate', 'Total Loss', '$ Impact'
        ],
        'allowed_rates': [
            levelName, 'Prev Avg Rate', 'Cur Avg Rate', 'Change', '$ Impact'
        ],
        'cpt_mix': [
            levelName, 'Eval %', 'High-Value %', 'Units/Visit', '$ Impact'
        ],
        'operational_leakage': [
            levelName, 'No-Show Rate', 'Cancel Rate', 'Efficiency', '$ Impact'
        ],
        'documentation_issues': [
            levelName, 'Unbilled %', 'Avg Lag Days', 'Missing Docs', '$ Impact'
        ]
    };
    
    return driverColumns[driverKey] || [levelName, 'Current Value', 'Prior Value', 'Change', '$ Impact'];
}

function updateDrillDownTable(data) {
    // Store the data for sorting
    currentTableData = data;
    
    // Check tracking status for all entities before rendering
    checkTrackingStatusAndRender(data);
}

function checkTrackingStatusAndRender(data) {
    // If no data, just render empty table
    if (!data || data.length === 0) {
        renderTable(data);
        return;
    }
    
    // Build list of entities to check tracking status for
    const entities = data.map(row => ({
        entity_type: currentLevel,
        entity_id: row.id,
        driver: driver
    }));
    
    // Call API to check tracking status
    fetch('/api/tracking/status', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ entities: entities })
    })
    .then(response => response.json())
    .then(trackingStatus => {
        // Add tracking status to data
        const dataWithTracking = data.map(row => {
            const key = `${currentLevel}_${row.id}_${driver}`;
            return {
                ...row,
                isTracked: trackingStatus[key] || false
            };
        });
        
        renderTable(dataWithTracking);
    })
    .catch(error => {
        console.error('Error checking tracking status:', error);
        // Render without tracking status if there's an error
        renderTable(data);
    });
}

function renderTable(data) {
    const tbody = document.querySelector('#drillDownTable tbody');
    tbody.innerHTML = '';
    
    data.forEach((row, index) => {
        const tr = document.createElement('tr');
        tr.style.cursor = currentLevel !== 'therapist' ? 'pointer' : 'default';
        
        // Generate row data based on driver
        const rowData = generateRowData(driver, row);
        
        // Create table cells with special formatting for currency values
        const cells = rowData.map((cell, index) => {
            // Check if this is the $ Impact column (usually the last data column)
            const isImpactColumn = index === rowData.length - 1 && cell.includes('$');
            
            if (isImpactColumn) {
                let cssClass = 'neutral-currency';
                if (cell.includes('(') && cell.includes(')')) {
                    cssClass = 'negative-currency';
                } else if (cell.includes('$') && !cell.includes('(')) {
                    cssClass = 'positive-currency';
                }
                return `<td><span class="${cssClass}">${cell}</span></td>`;
            }
            return `<td>${cell}</td>`;
        }).join('');
        
        // Determine track button state based on tracking status
        const isTracked = row.isTracked || false;
        const buttonClass = isTracked ? 'btn btn-sm btn-success track-btn' : 'btn btn-sm btn-outline-primary track-btn';
        const buttonText = isTracked ? '✓ Tracked' : 'Track';
        const buttonOnClick = isTracked ? '' : `onclick="trackItem(event, '${row.name}', '${driver}', ${row.id})"`;
        
        tr.innerHTML = `
            ${cells}
            <td>
                <button class="${buttonClass}" 
                        data-entity-id="${row.id}" 
                        data-entity-name="${row.name}" 
                        ${buttonOnClick}>
                    ${buttonText}
                </button>
            </td>
        `;
        
        // Add click handler for drill-down (except for therapist level)
        if (currentLevel !== 'therapist') {
            tr.onclick = function(event) {
                // Don't drill down if clicking the track button
                if (event.target.classList.contains('track-btn') || event.target.closest('.track-btn')) {
                    return;
                }
                drillDown(row.id, row.name);
            };
            tr.onmouseover = function() {
                this.style.backgroundColor = '#f8f9fa';
            };
            tr.onmouseout = function() {
                this.style.backgroundColor = '';
            };
        }
        
        tbody.appendChild(tr);
    });
}

function generateRowData(driverKey, row) {
    // Use actual calculated data from the API instead of random data
    const name = row.name;
    
    // Helper function to format negative numbers with parentheses and thousands separators
    function formatCurrency(value) {
        const absValue = Math.abs(value).toFixed(0);
        const formattedValue = parseInt(absValue).toLocaleString();
        
        if (value < 0) {
            return `($${formattedValue})`;
        }
        return `$${formattedValue}`;
    }
    
    function formatDecimal(value, places = 1) {
        if (value < 0) {
            return `(${Math.abs(value).toFixed(places)})`;
        }
        return value.toFixed(places);
    }
    
    // Calculate actual metrics using real data
    const currentUnitsPerVisit = row.units_per_visit || 0;
    const priorUnitsPerVisit = row.prior_units_per_visit || 0;
    const currentVisits = row.visits || 0;
    
    switch(driverKey) {
        case 'units_per_visit':
            const unitsChange = currentUnitsPerVisit - priorUnitsPerVisit;
            const unitsImpact = unitsChange * 25 * currentVisits; // $25 per unit change * visits
            return [
                name, 
                priorUnitsPerVisit.toFixed(1), 
                currentUnitsPerVisit.toFixed(1), 
                formatDecimal(unitsChange, 1), 
                formatCurrency(unitsImpact)
            ];
            
        case 'copay_leakage':
        case 'copay_collection':
            const currentExpected = (row.total_copay_expected || 0) / currentVisits;
            const currentCollected = (row.total_copay_collected || 0) / currentVisits;
            const priorExpected = (row.prior_copay_expected || 0) / (row.prior_visits || 1);
            const priorCollected = (row.prior_copay_collected || 0) / (row.prior_visits || 1);
            
            const currentCapture = currentExpected > 0 ? (currentCollected / currentExpected) * 100 : 0;
            const priorCapture = priorExpected > 0 ? (priorCollected / priorExpected) * 100 : 0;
            
            const copayLeakageChange = (currentExpected - currentCollected) - (priorExpected - priorCollected);
            const copayImpact = copayLeakageChange * currentVisits * -1; // Negative because leakage is bad
            
            return [
                name, 
                `$${currentExpected.toFixed(2)}`, 
                `$${currentCollected.toFixed(2)}`, 
                `${currentCapture.toFixed(1)}%`, 
                formatCurrency(copayImpact)
            ];
            
        case 'payer_mix':
            // Use visit patterns to simulate payer mix (simplified for prototype)
            const visitId = row.id || 1;
            const medicare = (15 + (visitId * 7) % 25).toFixed(1);
            const commercial = (40 + (visitId * 11) % 30).toFixed(1);
            const medicaid = (10 + (visitId * 3) % 15).toFixed(1);
            
            // Calculate impact based on net rate difference
            const netRateChange = (row.avg_net_rate || 0) - (row.prior_avg_net_rate || 0);
            const mixImpact = netRateChange * currentVisits * 0.3; // 30% attributed to payer mix
            
            return [
                name, 
                `${medicare}%`, 
                `${commercial}%`, 
                `${medicaid}%`, 
                formatCurrency(mixImpact)
            ];
            
        case 'writeoffs_denials':
            const currentWriteoffs = (row.total_writeoffs || 0) / currentVisits;
            const priorWriteoffs = (row.prior_writeoffs || 0) / (row.prior_visits || 1);
            const writeoffChange = currentWriteoffs - priorWriteoffs;
            
            const denialRate = Math.min(15, Math.abs(writeoffChange) * 100).toFixed(1); // Simulated
            const writeoffImpact = writeoffChange * currentVisits * -1; // Negative because writeoffs reduce revenue
            
            return [
                name, 
                `$${currentWriteoffs.toFixed(2)}`, 
                `${denialRate}%`, 
                `$${Math.abs(writeoffChange * currentVisits).toFixed(0)}`, 
                formatCurrency(writeoffImpact)
            ];
            
        default:
            const currentRate = row.avg_net_rate || 0;
            const priorRate = row.prior_avg_net_rate || 0;
            const rateChange = currentRate - priorRate;
            const rateImpact = rateChange * currentVisits;
            
            return [
                name, 
                priorRate.toFixed(2), 
                currentRate.toFixed(2), 
                formatDecimal(rateChange, 2), 
                formatCurrency(rateImpact)
            ];
    }
}

function drillDown(id, name) {
    // Save current state to navigation stack
    navigationStack.push({
        level: currentLevel,
        parentId: currentParentId,
        title: document.getElementById('drillTitle').textContent
    });
    
    // Update navigation state
    currentParentId = id;
    
    // Determine next level
    const nextLevel = {
        'region': 'market',
        'market': 'clinic', 
        'clinic': 'therapist'
    };
    
    currentLevel = nextLevel[currentLevel] || 'therapist';
    
    // Update UI
    const levelNames = {
        'market': 'Markets',
        'clinic': 'Clinics',
        'therapist': 'Therapists'
    };
    
    document.getElementById('drillTitle').textContent = 
        `${driver.replace('_', ' ').toUpperCase()} by ${levelNames[currentLevel]} in ${name}`;
    
    updateDrillDown();
    updateBackButton();
}

function drillUp() {
    if (navigationStack.length > 0) {
        // Navigate back in the drill-down hierarchy
        const previousState = navigationStack.pop();
        currentLevel = previousState.level;
        currentParentId = previousState.parentId;
        document.getElementById('drillTitle').textContent = previousState.title;
        updateDrillDown();
        updateBackButton();
    } else {
        // If no navigation history, go back to Dashboard
        window.location.href = '/';
    }
}

function updateBackButton() {
    const backBtn = document.getElementById('backUpBtn');
    const backText = document.getElementById('backUpText');
    
    if (navigationStack.length > 0) {
        // Show what level we'll go back to
        const previousState = navigationStack[navigationStack.length - 1];
        const levelNames = {
            'region': 'Regions',
            'market': 'Markets', 
            'clinic': 'Clinics'
        };
        backText.textContent = `← Back to ${levelNames[previousState.level] || 'Previous Level'}`;
    } else {
        // At top level, go back to dashboard
        backText.textContent = '← Back to Dashboard';
    }
}

function updateBreadcrumb() {
    const breadcrumb = document.getElementById('drillBreadcrumb');
    let breadcrumbHTML = `
        <li class="breadcrumb-item"><a href="{{ url_for('index') }}">Dashboard</a></li>
        <li class="breadcrumb-item"><a href="/drill-down/${driver}">${driver.replace('_', ' ').toUpperCase()}</a></li>
    `;
    
    // Add navigation breadcrumbs based on stack
    navigationStack.forEach((state, index) => {
        breadcrumbHTML += `<li class="breadcrumb-item"><a href="#" onclick="drillToStackLevel(${index})">${state.level.toUpperCase()}</a></li>`;
    });
    
    breadcrumbHTML += `<li class="breadcrumb-item active">${currentLevel.toUpperCase()}</li>`;
    breadcrumb.innerHTML = breadcrumbHTML;
}

function drillToStackLevel(stackIndex) {
    // Navigate back to a specific level in the stack
    const targetState = navigationStack[stackIndex];
    
    // Remove everything after this level from the stack
    navigationStack = navigationStack.slice(0, stackIndex + 1);
    
    // Restore the state
    const restoredState = navigationStack.pop();
    currentLevel = restoredState.level;
    currentParentId = restoredState.parentId;
    document.getElementById('drillTitle').textContent = restoredState.title;
    
    updateDrillDown();
    updateBackButton();
}

function sortTableByColumn(columnIndex, headerElement) {
    // Toggle sort direction if clicking the same column
    if (currentSortColumn === columnIndex) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        currentSortDirection = 'asc';
        currentSortColumn = columnIndex;
    }
    
    // Update sort indicators
    document.querySelectorAll('.sort-indicator').forEach(indicator => {
        indicator.textContent = '';
    });
    
    const indicator = headerElement.querySelector('.sort-indicator');
    indicator.textContent = currentSortDirection === 'asc' ? ' ↑' : ' ↓';
    
    // Sort the data
    const sortedData = [...currentTableData].sort((a, b) => {
        const aRowData = generateRowData(driver, a);
        const bRowData = generateRowData(driver, b);
        
        const aValue = aRowData[columnIndex];
        const bValue = bRowData[columnIndex];
        
        // Parse values for sorting
        const aParsed = parseValueForSorting(aValue);
        const bParsed = parseValueForSorting(bValue);
        
        let comparison = 0;
        if (typeof aParsed === 'number' && typeof bParsed === 'number') {
            comparison = aParsed - bParsed;
        } else {
            comparison = String(aParsed).localeCompare(String(bParsed));
        }
        
        return currentSortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-render the table with sorted data (with tracking status check)
    checkTrackingStatusAndRender(sortedData);
}

function parseValueForSorting(value) {
    // Remove $ symbols and parentheses, convert to numbers where possible
    if (typeof value === 'string') {
        // Handle currency values like "$1,234" or "($1,234)"
        if (value.includes('$')) {
            let numStr = value.replace(/[$,()]/g, '');
            if (value.includes('(') && value.includes(')')) {
                numStr = '-' + numStr;
            }
            const parsed = parseFloat(numStr);
            return isNaN(parsed) ? value : parsed;
        }
        
        // Handle percentage values like "85.2%"
        if (value.includes('%')) {
            const parsed = parseFloat(value.replace('%', ''));
            return isNaN(parsed) ? value : parsed;
        }
        
        // Handle regular numbers (including those with parentheses for negatives)
        if (value.includes('(') && value.includes(')')) {
            const numStr = '-' + value.replace(/[()]/g, '');
            const parsed = parseFloat(numStr);
            return isNaN(parsed) ? value : parsed;
        }
        
        // Try to parse as number
        const parsed = parseFloat(value);
        return isNaN(parsed) ? value : parsed;
    }
    
    return value;
}

function trackItem(event, itemName, driverName, entityId) {
    // Prevent the event from bubbling up to the row click handler
    event.stopPropagation();
    
    const button = event.target;
    const entityType = currentLevel; // region, market, clinic, therapist
    
    // Disable button and show loading state
    button.disabled = true;
    button.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Adding...';
    
    const trackingData = {
        entity_name: itemName,
        entity_type: entityType,
        entity_id: entityId,
        driver: driverName,
        baseline_value: 0 // We can enhance this later with actual baseline calculation
    };
    
    fetch('/api/tracking', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(trackingData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            // Reset button on error
            button.disabled = false;
            button.innerHTML = 'Track';
            button.classList.remove('btn-outline-primary');
            button.classList.add('btn-outline-danger');
            setTimeout(() => {
                button.classList.remove('btn-outline-danger');
                button.classList.add('btn-outline-primary');
            }, 3000);
        } else {
            // Success state - change button to indicate it's tracked
            button.disabled = false;
            button.innerHTML = '✓ Tracked';
            button.classList.remove('btn-outline-primary');
            button.classList.add('btn-success');
            button.onclick = null; // Remove click handler
            
            // Optional: Add a small success animation
            button.style.transform = 'scale(1.1)';
            setTimeout(() => {
                button.style.transform = 'scale(1)';
            }, 200);
        }
    })
    .catch(error => {
        console.error('Error tracking item:', error);
        // Reset button on error
        button.disabled = false;
        button.innerHTML = 'Track';
        button.classList.remove('btn-outline-primary');
        button.classList.add('btn-outline-danger');
        setTimeout(() => {
            button.classList.remove('btn-outline-danger');
            button.classList.add('btn-outline-primary');
        }, 3000);
    });
}

function loadActionRecommendations() {
    const recommendations = getRecommendationsForDriver(driver);
    const container = document.getElementById('actionRecommendations');
    
    container.innerHTML = `
        <h6>Recommended Actions for ${driver.replace('_', ' ').toUpperCase()}:</h6>
        <ul class="list-unstyled">
            ${recommendations.map(action => `<li>• ${action}</li>`).join('')}
        </ul>
    `;
}

function getRecommendationsForDriver(driverKey) {
    // Generic recommendations for all drivers
    return [
        'Recommended action 1',
        'Recommended action 2', 
        'Recommended action 3'
    ];
}

// Filter persistence functions (shared with dashboard)
function saveFilterSettings() {
    const filterSettings = {
        analysisView: document.getElementById('analysisView').value,
        currentMonth: document.getElementById('currentMonth').value,
        currentYear: document.getElementById('currentYear').value,
        regionFilter: '' // Drill-down doesn't have region filter, but we preserve it
    };
    
    // Merge with existing settings to preserve region filter from dashboard
    const existing = sessionStorage.getItem('netRateFilters');
    if (existing) {
        try {
            const existingSettings = JSON.parse(existing);
            if (existingSettings.regionFilter !== undefined) {
                filterSettings.regionFilter = existingSettings.regionFilter;
            }
        } catch (e) {
            console.error('Error merging filter settings:', e);
        }
    }
    
    sessionStorage.setItem('netRateFilters', JSON.stringify(filterSettings));
}

function loadFilterSettings() {
    const saved = sessionStorage.getItem('netRateFilters');
    if (saved) {
        try {
            const filterSettings = JSON.parse(saved);
            
            // Apply saved settings to form controls (only the ones that exist on this page)
            if (filterSettings.analysisView) {
                document.getElementById('analysisView').value = filterSettings.analysisView;
            }
            if (filterSettings.currentMonth) {
                document.getElementById('currentMonth').value = filterSettings.currentMonth;
            }
            if (filterSettings.currentYear) {
                document.getElementById('currentYear').value = filterSettings.currentYear;
            }
        } catch (e) {
            console.error('Error loading filter settings:', e);
        }
    }
}
</script>
{% endblock %}